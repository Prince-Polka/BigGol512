http://thebookofshaders.com/edit.php?log=170611102132

#ifdef GL_ES
precision mediump float;
#endif
vec4 u_colors[2];
vec4 background = vec4(0.268,0.286,0.370,1.000);
int u_num;
uniform vec2 u_mouse;

// this array shall contain all shape data neeeded to render, and supplied from processing
vec2 verts [4];
vec4 fills [4];
vec4 strokes [4];
int shape[5];


// distance things
float distroot(in vec2 A, in vec2 B) {
    A=abs(A-B);
    A*=A;
return sqrt(A.x+A.y);
}
float dist(in vec2 A, in vec2 B) {
float p,q,r,s;
A=abs(A-B);
p = max(A.x,A.y);
q = min(A.x,A.y);
r=q/p;
r*=r;
s=r/(4.0+r);
p+=2.0*s*p;
return p;
}
bool closerThan(float len, vec2 A, vec2 B){
  vec2 del = A-B;
  del*=del;
  len*=len;
  return del.x+del.y < len;
}

// shapes

bool ellipse(vec2 pos, vec2 size) {
    vec2 e = ( gl_FragCoord.xy - pos) / size;
    e*=e;
    if( e.x+e.y < 1. ) { return true; }
    return false;
}

// quad uses triangle which uses side

bool side( vec2 A, vec2 B) {
    return dot(vec2(B.y-A.y,A.x-B.x),gl_FragCoord.xy-A)>=0.;
}
bool triangle(vec2 A, vec2 B, vec2 C) {
 bool a = side(A,B);
 bool b = side(B,C);
 if(a!=b){return false;}
 bool c = side(C,A);
 return b==c;
}

bool quad(vec2 A, vec2 B, vec2 C, vec2 D){
   return triangle(A,B,C) || triangle(C,D,A);
}



//line uses project and constrain
vec2 project(vec2 A, vec2 B, vec2 C){
    vec2 L = B-A;
    float K = dot(C-A,L);
    K/= dot(L,L);
    return A+L*K;
}

vec2 constrain (vec2 amt, vec2 low, vec2 high){
    //return clamp(amt,min(low,high),max(low,high));
    return min(max(amt,min(low,high)),max(low,high));
}

bool line (vec2 A, vec2 B, float thickness){
    vec2 C = gl_FragCoord.xy;
    vec2 D = constrain(project(A,B,C),A,B);
    if ( closerThan ( thickness,C,D) ) { 
        return true; 
    }
    //return false;
}

// bezier uses bezierpoint and line

vec2 bezierPoint(vec2 A, vec2 B, vec2 C, vec2 D, float T) { 
    vec2 AB = mix(A,B,T);
    vec2 BC = mix(B,C,T);
    vec2 CD = mix(C,D,T);
    return mix( mix(AB,BC,T) , mix(BC,CD,T) , T );
}

bool bezier(vec2 A, vec2 B, vec2 C, vec2 D){
    float I=0.0;
    vec2 prev=bezierPoint(A,B,C,D,0.);
    vec2 cur;
for (int i=0; i<10; i++){
    I+=0.1;
    cur = bezierPoint(A,B,C,D,I);
    if( line(prev,cur,10.) ){
        return true;
    }
    prev =cur;
}
    return false;
}

/*
shall have blendmodes for alpha transparency etc
ID's for processing Blendmodes  ( might not be completely implemented ) 
0 REPLACE
1 BLEND
2 ADD
8 LIGHTEST
16 DARKEST
32 DIFFERENCE
64 EXLUSION
128 MULTIPLY
256 SCREEN
*/

vec4 blend(vec4 background , vec4 foreground, int mode){
    // REPLACE
    if (mode == 0){
        return foreground;
    }
    //BLEND
    if (mode == 1){
        //return ;
    }
    //ADD
    if (mode == 2){
        return background+foreground; //MIGHT NOT BE RIGHT
    }
    //LIGHTEST
    if (mode == 8){
        //return ;
    }
    //DARKEST
    if (mode == 16){
        //return ;
    }
    //DIFFERNCE
    if (mode == 32){
        //return;
    }
    //EXCLUSION
    if (mode == 64){
        //return ;
    }
    //MULTIPLY
    if (mode == 128){
        //return ;
    }
    //SCREEN
    if (mode == 256){
        //return ;
    }
    
}

void main() {
    vec4 frag=background;
    int i=0;
    int vertindex=0;
    // these arrays shall be set by processing but setting manually while coding
    

    // consolidating all verts into one array might not work because of array lookup having to be constant
    
    verts[0] = vec2(27.,225.);
    verts[1] = vec2(95.,208.);
    verts[2] = vec2(240.,300.);
    verts[3] = vec2(320.,100.);
    
    fills[0] = vec4(0.420,0.184,0.261,1.000);
    fills[1] = vec4(0.269,0.625,0.273,1.000);
    fills[2] = vec4(0.264,0.625,0.307,1.000);
    fills[3] = vec4(0.194,0.165,0.730,1.000);
    strokes[0] = vec4(0.805,0.703,0.332,1.000);
    strokes[1] = vec4(0.785,0.373,0.335,1.000);
    strokes[2] = vec4(0.520,0.397,0.795,1.000);
    strokes[3] = vec4(0.380,0.695,0.253,1.000);
    
    // array containing what type of shape each shape is , 0 = no shape to break loop , 1= line etc
    
    shape[0] = 1;
    shape[1] = 2;
    shape[2] = 3;
    shape[3] = 4;
    shape[4] = 0;
    
    // main function shall loop through arrays to render fragments from array data, from background to forefront
    //if(shape[i]==1){
        //if (line(verts[vertindex],verts[vertindex+1],10.)){
            
        //}
        //vertindex+=2;
    //}
    if ( line( vec2(40.,380.) , vec2(200.,340.) , 10. ) ){
       frag = blend (frag,strokes[0],0);
    }
    i++;
    if ( bezier(vec2(27.,225.),vec2(95.,208.),vec2(240.,300.),vec2(320.,100.))  ) {
        frag = blend (frag,strokes[1],0);
    }
    i++;
    if(ellipse(vec2(400.,300.),vec2(100.,200))){
        frag = blend (frag,fills[2],0);
    }
    i++;
    if( triangle( vec2(200.100) , vec2(10.100) , vec2(350.,100.) ) ){
        frag = blend (frag,fills[3],0);
    }
    
gl_FragColor = frag;
}
